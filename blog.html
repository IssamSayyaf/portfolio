<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <link rel="icon" type="image/png" href="assets/images/icon.png">
    <title>Blog - Issam Sayyaf</title>
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css" />
    <style>
        html {
            zoom: 1.0;
            -moz-transform: scale(1.0);
            -moz-transform-origin: 0 0;
        }
        
        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background: #f8f9fa;
            max-width: 1400px;
            margin: 0 auto;
            padding: 20px;
            color: #2c3e50;
            transform-origin: top left;
        }
        .header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 1rem;
            background: rgba(255, 255, 255, 0.95);
            border-radius: 15px;
            box-shadow: 0 2px 10px rgba(0,0,0,0.1);
            margin-bottom: 40px;
        }
        .logo {
            font-size: 1.2rem;
            color: #0066cc;
            text-decoration: none;
        }
        nav a {
            color: #666;
            text-decoration: none;
            margin-left: 20px;
            transition: color 0.3s ease;
        }
        nav a.active, nav a:hover {
            color: #0066cc;
        }
        main {
            background: white;
            padding: 30px;
            border-radius: 20px;
            box-shadow: 0 8px 32px rgba(0,0,0,0.1);
        }
        
        /* Blog specific styles */
        .blog-post {
            margin-bottom: 60px;
            padding-bottom: 40px;
            border-bottom: 1px solid #eee;
        }
        .blog-post:last-child {
            border-bottom: none;
        }
        .blog-post-header {
            margin-bottom: 20px;
        }
        .blog-post-title {
            font-size: 2rem;
            color: #1565C0;
            margin-bottom: 10px;
        }
        .blog-post-meta {
            display: flex;
            align-items: center;
            color: #78909c;
            font-size: 0.9rem;
            margin-bottom: 15px;
        }
        .blog-post-meta > * {
            margin-right: 15px;
            display: flex;
            align-items: center;
        }
        .blog-post-meta i {
            margin-right: 5px;
        }
        .blog-post-image {
            width: 100%;
            border-radius: 10px;
            margin-bottom: 20px;
            box-shadow: 0 4px 10px rgba(0,0,0,0.1);
        }
        .blog-post-content {
            line-height: 1.7;
        }
        .blog-post-content p {
            margin-bottom: 20px;
        }
        .blog-post-content h2 {
            margin-top: 30px;
            margin-bottom: 15px;
            color: #0066cc;
        }
        .blog-post-content h3 {
            margin-top: 25px;
            margin-bottom: 12px;
            color: #1976D2;
            font-size: 1.3rem;
        }
        .blog-post-content ul, .blog-post-content ol {
            margin-bottom: 20px;
            padding-left: 20px;
        }
        .blog-post-content li {
            margin-bottom: 8px;
        }
        .blog-post-tags {
            display: flex;
            flex-wrap: wrap;
            gap: 10px;
            margin-top: 30px;
        }
        .blog-tag {
            background: #e1f5fe;
            color: #0277bd;
            padding: 5px 12px;
            border-radius: 20px;
            font-size: 0.85rem;
            transition: all 0.3s ease;
        }
        .blog-tag:hover {
            background: #b3e5fc;
            transform: translateY(-2px);
        }
        .read-more {
            display: inline-block;
            margin-top: 20px;
            color: #0066cc;
            font-weight: 500;
            transition: all 0.3s ease;
        }
        .read-more:hover {
            color: #004c99;
            text-decoration: underline;
        }
        
        /* Sidebar styles */
        .blog-container {
            display: flex;
            gap: 40px;
        }
        .blog-main {
            flex: 3;
        }
        .blog-sidebar {
            flex: 1;
        }
        .sidebar-section {
            background: #f8f9fa;
            border-radius: 10px;
            padding: 20px;
            margin-bottom: 30px;
            box-shadow: 0 2px 10px rgba(0,0,0,0.05);
        }
        .sidebar-title {
            font-size: 1.2rem;
            color: #1565C0;
            margin-bottom: 15px;
            padding-bottom: 10px;
            border-bottom: 2px solid #e1f5fe;
        }
        .categories-list, .recent-posts-list {
            list-style: none;
            padding: 0;
        }
        .categories-list li, .recent-posts-list li {
            padding: 8px 0;
            border-bottom: 1px dashed #e0e0e0;
        }
        .categories-list li:last-child, .recent-posts-list li:last-child {
            border-bottom: none;
        }
        .categories-list a, .recent-posts-list a {
            color: #455a64;
            text-decoration: none;
            transition: color 0.3s ease;
            display: block;
        }
        .categories-list a:hover, .recent-posts-list a:hover {
            color: #0066cc;
            transform: translateX(5px);
        }
        .recent-posts-list .post-date {
            font-size: 0.8rem;
            color: #90a4ae;
            display: block;
        }
        
        /* Footer styles */
        footer {
            text-align: center;
            margin-top: 40px;
            padding: 20px;
            color: #546e7a;
        }
        
        /* Responsive styles */
        @media (max-width: 992px) {
            .blog-container {
                flex-direction: column;
            }
            .blog-sidebar {
                display: flex;
                flex-wrap: wrap;
                gap: 20px;
            }
            .sidebar-section {
                flex: 1;
                min-width: 250px;
            }
        }
        
        @media (max-width: 768px) {
            .blog-post-title {
                font-size: 1.8rem;
            }
            .blog-sidebar {
                flex-direction: column;
            }
        }
        
        @media (max-width: 576px) {
            .blog-post-meta {
                flex-wrap: wrap;
                gap: 10px;
            }
            .blog-post-meta > * {
                margin-right: 0;
            }
        }
        
        /* Code styles */
        pre {
            background-color: #f5f7f9;
            border-radius: 6px;
            border-left: 4px solid #2196F3;
            padding: 15px;
            margin: 20px 0;
            overflow-x: auto;
            font-family: 'Monaco', 'Menlo', 'Ubuntu Mono', 'Consolas', 'source-code-pro', monospace;
            font-size: 0.9rem;
            line-height: 1.5;
        }
        code {
            font-family: 'Monaco', 'Menlo', 'Ubuntu Mono', 'Consolas', 'source-code-pro', monospace;
            background-color: #f1f1f1;
            padding: 2px 4px;
            border-radius: 3px;
            font-size: 0.9rem;
            color: #0D47A1;
        }
        pre code {
            background-color: transparent;
            padding: 0;
            border-radius: 0;
            color: #333;
        }
    </style>
</head>
<body>
    <header class="header">
        <a href="index.html" class="logo">Issam Sayyaf</a>
        <nav>
            <a href="index.html">Home</a>
            <a href="projects.html">Projects</a>
            <a href="blog.html" class="active">Blog</a>
        </nav>
    </header>
    
    <main>
        <div class="blog-container">
            <div class="blog-main">
                <h1 class="page-title">Technical Blog</h1>
                
                <article class="blog-post">
                    <header class="blog-post-header">
                        <h2 class="blog-post-title">Building Custom Linux Distributions with Yocto Project</h2>
                        <div class="blog-post-meta">
                            <span><i class="far fa-calendar-alt"></i> June 15, 2024</span>
                            <span><i class="far fa-user"></i> Issam Sayyaf</span>
                            <span><i class="far fa-folder"></i> Embedded Linux</span>
                        </div>
                    </header>
                    
                    <img src="assets/images/yocto.jpg" alt="Yocto Project" class="blog-post-image">
                    
                    <div class="blog-post-content">
                        <p>The Yocto Project provides a flexible framework for creating custom Linux distributions tailored to specific hardware platforms. In this article, I'll share my experience using Yocto to build optimized operating systems for embedded devices, focusing on performance and security considerations.</p>
                        
                        <h2>Understanding the Yocto Project Architecture</h2>
                        
                        <p>Yocto's layer-based architecture allows developers to modularize their customizations and easily incorporate them into existing distributions. By leveraging this approach, I've been able to create streamlined Linux images that include only the components necessary for target applications, resulting in smaller footprints and improved security posture.</p>
                        
                        <p>The key components of the Yocto Project ecosystem include:</p>
                        <ul>
                            <li><strong>BitBake:</strong> The task execution engine that parses recipes and executes tasks according to their dependencies</li>
                            <li><strong>OpenEmbedded-Core (OE-Core):</strong> The core metadata that provides the foundation for building Linux distributions</li>
                            <li><strong>Layers:</strong> Collections of recipes, configurations, and other files that can be added or removed to customize the distribution</li>
                            <li><strong>Recipes:</strong> Files that define how to fetch, configure, compile, and install packages</li>
                            <li><strong>Board Support Packages (BSPs):</strong> Layers that contain hardware-specific configurations and drivers</li>
                        </ul>
                        
                        <h2>Setting Up a Yocto Build Environment</h2>
                        
                        <p>Setting up a Yocto build environment requires careful consideration of system requirements and configurations. Here's a step-by-step approach I follow when starting a new Yocto-based project:</p>
                        
                        <ol>
                            <li>Install essential build tools and dependencies:
                                <pre><code>sudo apt-get install gawk wget git diffstat unzip texinfo gcc-multilib \
build-essential chrpath socat cpio python3 python3-pip python3-pexpect \
xz-utils debianutils iputils-ping python3-git python3-jinja2 libegl1-mesa \
libsdl1.2-dev pylint3 xterm</code></pre>
                            </li>
                            <li>Clone the Poky repository (the reference distribution of Yocto):
                                <pre><code>git clone git://git.yoctoproject.org/poky
cd poky
git checkout -b langdale origin/langdale</code></pre>
                            </li>
                            <li>Initialize the build environment:
                                <pre><code>source oe-init-build-env build</code></pre>
                            </li>
                            <li>Configure build settings by modifying <code>conf/local.conf</code> and <code>conf/bblayers.conf</code> files</li>
                            <li>Add additional layers as needed for specific hardware support:
                                <pre><code>git clone git://git.openembedded.org/meta-openembedded
git clone git://git.yoctoproject.org/meta-stm32mp1</code></pre>
                            </li>
                        </ol>
                        
                        <h2>Creating a Custom Distribution</h2>
                        
                        <p>For my embedded projects, particularly the Muzziball device, I created a custom distribution layer that defines specific requirements and configurations. This approach allowed me to achieve the following:</p>
                        
                        <ul>
                            <li>Minimal base system with only essential components</li>
                            <li>Custom boot splash and branding</li>
                            <li>Integrated device-specific services and applications</li>
                            <li>Optimized performance for the target hardware</li>
                            <li>Comprehensive security hardening measures</li>
                        </ul>
                        
                        <p>The distribution layer typically includes:</p>
                        <pre><code>meta-custom-distro/
  ├── conf/
  │   ├── distro/
  │   │   └── custom-distro.conf
  │   └── layer.conf
  ├── recipes-core/
  │   ├── images/
  │   │   └── custom-image.bb
  │   └── packagegroups/
  │       └── packagegroup-custom.bb
  └── recipes-custom/
      └── custom-app/
          └── custom-app.bb</code></pre>
                        
                        <h2>BSP Development for STM32MP1</h2>
                        
                        <p>One of the more challenging aspects of Yocto development is creating or adapting Board Support Packages (BSPs) for specific hardware. For the Muzziball project, I worked extensively with the STM32MP1 platform, which required:</p>
                        
                        <ul>
                            <li>Customizing device tree files to match our specific hardware configuration</li>
                            <li>Developing custom drivers for specialized hardware components</li>
                            <li>Configuring bootloader settings for optimal startup performance</li>
                            <li>Implementing power management optimizations</li>
                            <li>Integrating hardware-accelerated graphics capabilities</li>
                        </ul>
                        
                        <p>The process involved close collaboration with hardware engineers to ensure all peripherals were properly supported and optimized for the target application.</p>
                        
                        <h2>Security Considerations</h2>
                        
                        <p>Security is paramount in embedded Linux systems, especially for IoT devices. My Yocto builds incorporate several security enhancements:</p>
                        
                        <ul>
                            <li>Secure boot implementation using hardware cryptographic elements</li>
                            <li>Regular security patch integration through package version updates</li>
                            <li>Removal of unnecessary services and packages to reduce attack surface</li>
                            <li>Implementation of read-only root filesystem with overlay for runtime changes</li>
                            <li>Hardened kernel configurations following industry best practices</li>
                            <li>Integrated intrusion detection mechanisms</li>
                        </ul>
                        
                        <h2>CI/CD Pipeline Integration</h2>
                        
                        <p>To maintain consistent build quality and automate testing, I integrated the Yocto build process into a CI/CD pipeline using GitLab CI. This setup provides:</p>
                        
                        <ul>
                            <li>Automated builds triggered by code changes</li>
                            <li>Reproducible build environments using Docker containers</li>
                            <li>Comprehensive testing of generated images using QEMU</li>
                            <li>Artifact management for generated images and SDKs</li>
                            <li>Automated deployment to target devices for field testing</li>
                        </ul>
                        
                        <h2>Conclusion</h2>
                        
                        <p>Working with the Yocto Project provides unparalleled flexibility and control when developing custom Linux distributions for embedded systems. While the learning curve can be steep, the benefits in terms of customization, optimization, and security make it an invaluable tool for serious embedded Linux development.</p>
                        
                        <p>For developers considering Yocto for their projects, I recommend starting with a well-established distribution like Poky and gradually introducing customizations as you become more familiar with the ecosystem. The investment in learning this powerful framework pays dividends in the long run, especially for products that require ongoing maintenance and updates.</p>
                        
                        <div class="blog-post-tags">
                            <span class="blog-tag">Yocto Project</span>
                            <span class="blog-tag">Embedded Linux</span>
                            <span class="blog-tag">BSP Development</span>
                            <span class="blog-tag">Custom Linux</span>
                            <span class="blog-tag">STM32MP1</span>
                        </div>
                    </div>
                </article>
                
                <article class="blog-post">
                    <header class="blog-post-header">
                        <h2 class="blog-post-title">Implementing Secure IoT Systems: Best Practices and Pitfalls</h2>
                        <div class="blog-post-meta">
                            <span><i class="far fa-calendar-alt"></i> May 22, 2024</span>
                            <span><i class="far fa-user"></i> Issam Sayyaf</span>
                            <span><i class="far fa-folder"></i> IoT Security</span>
                        </div>
                    </header>
                    
                    <img src="assets/images/arch_esp32_iot_project.jpeg" alt="IoT Security Architecture" class="blog-post-image">
                    
                    <div class="blog-post-content">
                        <p>Security remains one of the most critical challenges in IoT system development. Based on my experience implementing AWS-integrated IoT solutions, I've compiled essential security practices that every developer should consider when building connected devices.</p>
                        
                        <h2>The Security Challenges in IoT</h2>
                        
                        <p>From secure boot implementations to certificate-based authentication and encrypted communication channels, there are multiple layers of security that must be addressed in a comprehensive IoT security strategy. This article explores practical approaches to securing each aspect of an IoT system, with real-world examples from my projects.</p>
                        
                        <p>IoT systems face unique security challenges compared to traditional IT infrastructure:</p>
                        
                        <ul>
                            <li>Resource constraints on embedded devices limiting security implementations</li>
                            <li>Physical accessibility of devices increasing vulnerability to tampering</li>
                            <li>Long deployment lifespans requiring sustainable update mechanisms</li>
                            <li>Heterogeneous ecosystems with varying security capabilities</li>
                            <li>Diverse communication protocols with different security models</li>
                        </ul>
                        
                        <h2>Device-Level Security Measures</h2>
                        
                        <p>Security begins at the device level, with fundamental protections built into the hardware and firmware. In my projects, I implement several key measures:</p>
                        
                        <h3>1. Secure Boot and Firmware Verification</h3>
                        
                        <p>For ESP32-based devices, I leverage the hardware secure boot capabilities to verify the authenticity of firmware at startup:</p>
                        
                        <pre><code>// Generate signing keys
espsecure.py generate_signing_key --version 2 secure_boot_signing_key.pem

// Configure secure boot in sdkconfig
CONFIG_SECURE_BOOT=y
CONFIG_SECURE_BOOT_V2_ENABLED=y
CONFIG_SECURE_BOOT_VERIFICATION_KEY="secure_boot_signing_key.pem"

// Sign the bootloader and application
espsecure.py sign_data --version 2 --keyfile secure_boot_signing_key.pem bootloader.bin
espsecure.py sign_data --version 2 --keyfile secure_boot_signing_key.pem application.bin</code></pre>
                        
                        <p>This ensures that only authorized firmware can run on the device, protecting against malicious code injection attacks.</p>
                        
                        <h3>2. Hardware Security Modules</h3>
                        
                        <p>When working with more advanced IoT products, I recommend incorporating dedicated hardware security modules (HSMs) or secure elements to store cryptographic keys and perform sensitive operations:</p>
                        
                        <ul>
                            <li>ATECC608A secure element for high-security requirements</li>
                            <li>ESP32's built-in eFuse for more cost-sensitive applications</li>
                            <li>Trusted Platform Modules (TPMs) for gateway devices</li>
                        </ul>
                        
                        <h3>3. Protected Storage</h3>
                        
                        <p>Sensitive data stored on the device must be protected using encryption and access controls:</p>
                        
                        <pre><code>// Example using ESP32's NVS encrypted storage
nvs_handle_t nvs_handle;
esp_err_t err;

// Initialize NVS encryption using a device-specific key
nvs_sec_cfg_t sec_cfg;
err = nvs_flash_read_security_cfg(&sec_cfg);
if (err == ESP_ERR_NVS_SEC_CFG_NOT_FOUND) {
    // Generate and store a new encryption key
    err = nvs_flash_generate_keys(&sec_cfg);
}

// Initialize encrypted NVS partition
err = nvs_flash_secure_init(&sec_cfg);

// Store sensitive data
nvs_open("storage", NVS_READWRITE, &nvs_handle);
nvs_set_str(nvs_handle, "auth_token", token_value);
nvs_commit(nvs_handle);
nvs_close(nvs_handle);</code></pre>
                        
                        <h2>Communication Security</h2>
                        
                        <p>Secure communication is essential for IoT systems, particularly when transmitting sensitive data or control commands.</p>
                        
                        <h3>1. TLS/SSL Implementation</h3>
                        
                        <p>For my AWS IoT projects, I implement TLS 1.2 or higher with strong cipher suites:</p>
                        
                        <pre><code>// Example TLS configuration for MQTT connection to AWS IoT
const esp_mqtt_client_config_t mqtt_cfg = {
    .uri = CONFIG_BROKER_URI,
    .client_cert_pem = (const char *)client_cert_pem_start,
    .client_key_pem = (const char *)client_key_pem_start,
    .cert_pem = (const char *)server_cert_pem_start,
    .transport = MQTT_TRANSPORT_OVER_SSL,
    .skip_cert_common_name_check = false,
    .alpn_protos = {"x-amzn-mqtt-ca"}, // AWS IoT specific
};</code></pre>
                        
                        <p>Key considerations for TLS implementations include:</p>
                        
                        <ul>
                            <li>Properly validating server certificates to prevent MITM attacks</li>
                            <li>Implementing certificate pinning for additional security</li>
                            <li>Ensuring cipher suites are regularly updated to address vulnerabilities</li>
                            <li>Properly managing certificate lifetimes and renewal processes</li>
                        </ul>
                        
                        <h3>2. Certificate-Based Authentication</h3>
                        
                        <p>For AWS IoT integration, I use X.509 certificates for device authentication:</p>
                        
                        <ol>
                            <li>Create a certificate signing request (CSR) on the device or securely provision pre-generated certificates</li>
                            <li>Register the device certificate with AWS IoT Core</li>
                            <li>Attach appropriate policies to the certificate to control permissions</li>
                            <li>Implement certificate rotation mechanisms for long-lived devices</li>
                        </ol>
                        
                        <h2>Cloud Infrastructure Security</h2>
                        
                        <p>The cloud components of an IoT system require careful security considerations:</p>
                        
                        <h3>1. AWS IoT Core Security Policies</h3>
                        
                        <p>I apply the principle of least privilege when defining AWS IoT policies:</p>
                        
                        <pre><code>{
  "Version": "2012-10-17",
  "Statement": [
    {
      "Effect": "Allow",
      "Action": "iot:Connect",
      "Resource": "arn:aws:iot:region:account-id:client/${iot:Connection.Thing.ThingName}"
    },
    {
      "Effect": "Allow",
      "Action": "iot:Publish",
      "Resource": "arn:aws:iot:region:account-id:topic/devices/${iot:Connection.Thing.ThingName}/data"
    },
    {
      "Effect": "Allow",
      "Action": "iot:Subscribe",
      "Resource": "arn:aws:iot:region:account-id:topicfilter/devices/${iot:Connection.Thing.ThingName}/commands"
    },
    {
      "Effect": "Allow",
      "Action": "iot:Receive",
      "Resource": "arn:aws:iot:region:account-id:topic/devices/${iot:Connection.Thing.ThingName}/commands"
    }
  ]
}</code></pre>
                        
                        <p>This policy restricts the device to only:</p>
                        <ul>
                            <li>Connect with its own thing name</li>
                            <li>Publish to its own data topic</li>
                            <li>Subscribe to its own commands topic</li>
                            <li>Receive messages from its own commands topic</li>
                        </ul>
                        
                        <h3>2. Data Storage Security</h3>
                        
                        <p>For data stored in AWS services like DynamoDB, I implement:</p>
                        
                        <ul>
                            <li>Server-side encryption for data at rest</li>
                            <li>IAM roles with minimal permissions for accessing the data</li>
                            <li>Attribute-based access control for fine-grained permissions</li>
                            <li>Data lifecycle policies to manage retention periods</li>
                        </ul>
                        
                        <h2>Monitoring and Incident Response</h2>
                        
                        <p>Security doesn't end with implementation; continuous monitoring is essential:</p>
                        
                        <h3>1. AWS IoT Device Defender</h3>
                        
                        <p>I configure AWS IoT Device Defender to:</p>
                        
                        <ul>
                            <li>Audit device configurations for security best practices</li>
                            <li>Monitor devices for abnormal behavior</li>
                            <li>Set up automated alerts for security violations</li>
                            <li>Implement automated remediation actions where appropriate</li>
                        </ul>
                        
                        <h3>2. Logging and Monitoring</h3>
                        
                        <p>Comprehensive logging helps identify and respond to security incidents:</p>
                        
                        <ul>
                            <li>AWS CloudWatch Logs for centralized log collection</li>
                            <li>Log analysis with CloudWatch Insights for pattern detection</li>
                            <li>Alerts based on suspicious activity patterns</li>
                            <li>Regular security reviews of logged data</li>
                        </ul>
                        
                        <h2>Common Pitfalls to Avoid</h2>
                        
                        <p>Through my experience developing secure IoT systems, I've identified several common mistakes:</p>
                        
                        <h3>1. Hardcoded Credentials</h3>
                        
                        <p>Never hardcode sensitive information like:</p>
                        <ul>
                            <li>API keys or access tokens</li>
                            <li>Encryption keys</li>
                            <li>Passwords or username/password combinations</li>
                            <li>Certificate private keys (in production code)</li>
                        </ul>
                        
                        <p>Instead, use secure storage mechanisms and runtime provisioning.</p>
                        
                        <h3>2. Insufficient Update Mechanisms</h3>
                        
                        <p>IoT devices need robust update capabilities:</p>
                        <ul>
                            <li>Secure OTA update infrastructure with signature verification</li>
                            <li>Failsafe recovery mechanisms for failed updates</li>
                            <li>Version tracking and compatibility checking</li>
                            <li>Testing procedures for updates before deployment</li>
                        </ul>
                        
                        <h3>3. Neglecting Physical Security</h3>
                        
                        <p>Physical access to devices can compromise security:</p>
                        <ul>
                            <li>Implement tamper detection where feasible</li>
                            <li>Disable debug interfaces in production</li>
                            <li>Use secure boot to prevent unauthorized firmware</li>
                            <li>Encrypt sensitive data storage</li>
                        </ul>
                        
                        <h2>Conclusion</h2>
                        
                        <p>Implementing secure IoT systems requires a comprehensive approach that addresses security at every layer of the stack. By following the practices outlined in this article, developers can build IoT solutions that protect both user data and infrastructure from evolving threats.</p>
                        
                        <p>Remember that security is not a one-time implementation but an ongoing process requiring continuous monitoring, updates, and improvements as new vulnerabilities and attack vectors emerge.</p>
                        
                        <div class="blog-post-tags">
                            <span class="blog-tag">IoT Security</span>
                            <span class="blog-tag">AWS IoT</span>
                            <span class="blog-tag">TLS/SSL</span>
                            <span class="blog-tag">Embedded Systems</span>
                            <span class="blog-tag">ESP32</span>
                            <span class="blog-tag">X.509</span>
                        </div>
                    </div>
                </article>
                
                <article class="blog-post">
                    <header class="blog-post-header">
                        <h2 class="blog-post-title">Advanced Signal Processing for Pedestrian Navigation Systems</h2>
                        <div class="blog-post-meta">
                            <span><i class="far fa-calendar-alt"></i> April 10, 2024</span>
                            <span><i class="far fa-user"></i> Issam Sayyaf</span>
                            <span><i class="far fa-folder"></i> Signal Processing</span>
                        </div>
                    </header>
                    
                    <img src="assets/images/step_detection_comparison.png" alt="Step Detection Analysis" class="blog-post-image">
                    
                    <div class="blog-post-content">
                        <p>Pedestrian navigation systems rely heavily on accurate signal processing to detect movement patterns and determine positioning. My recent research has focused on improving step detection algorithms by implementing anomaly filtering techniques that effectively distinguish between genuine walking signals and mimic movements.</p>
                        
                        <p>This article delves into the technical aspects of these algorithms, exploring autoencoder architectures for anomaly detection, feature extraction from IMU signals, and the integration of these components into complete PDR systems. Performance comparisons with traditional methods demonstrate significant improvements in positioning accuracy.</p>
                        
                        <div class="blog-post-tags">
                            <span class="blog-tag">Signal Processing</span>
                            <span class="blog-tag">Step Detection</span>
                            <span class="blog-tag">PDR</span>
                            <span class="blog-tag">Machine Learning</span>
                        </div>
                        
                        <a href="#" class="read-more">Read More →</a>
                    </div>
                </article>
            </div>
            
            <aside class="blog-sidebar">
                <div class="sidebar-section">
                    <h3 class="sidebar-title">Categories</h3>
                    <ul class="categories-list">
                        <li><a href="#">Embedded Systems <span>(5)</span></a></li>
                        <li><a href="#">Signal Processing <span>(3)</span></a></li>
                        <li><a href="#">IoT Security <span>(4)</span></a></li>
                        <li><a href="#">Embedded Linux <span>(6)</span></a></li>
                        <li><a href="#">Deep Learning <span>(2)</span></a></li>
                        <li><a href="#">Networking <span>(3)</span></a></li>
                    </ul>
                </div>
                
                <div class="sidebar-section">
                    <h3 class="sidebar-title">Recent Posts</h3>
                    <ul class="recent-posts-list">
                        <li>
                            <a href="#">Building Custom Linux Distributions with Yocto Project</a>
                            <span class="post-date">June 15, 2024</span>
                        </li>
                        <li>
                            <a href="#">Implementing Secure IoT Systems: Best Practices and Pitfalls</a>
                            <span class="post-date">May 22, 2024</span>
                        </li>
                        <li>
                            <a href="#">Advanced Signal Processing for Pedestrian Navigation Systems</a>
                            <span class="post-date">April 10, 2024</span>
                        </li>
                        <li>
                            <a href="#">Deep Learning Applications in Crack Detection Systems</a>
                            <span class="post-date">March 18, 2024</span>
                        </li>
                        <li>
                            <a href="#">Software-Defined Networking: Practical Implementations</a>
                            <span class="post-date">February 25, 2024</span>
                        </li>
                    </ul>
                </div>
                
                <div class="sidebar-section">
                    <h3 class="sidebar-title">Tags</h3>
                    <div class="blog-post-tags">
                        <span class="blog-tag">Yocto Project</span>
                        <span class="blog-tag">Embedded Linux</span>
                        <span class="blog-tag">IoT</span>
                        <span class="blog-tag">Security</span>
                        <span class="blog-tag">AWS</span>
                        <span class="blog-tag">Signal Processing</span>
                        <span class="blog-tag">PDR</span>
                        <span class="blog-tag">Deep Learning</span>
                        <span class="blog-tag">STM32</span>
                        <span class="blog-tag">BSP</span>
                        <span class="blog-tag">Networking</span>
                        <span class="blog-tag">SDN</span>
                    </div>
                </div>
            </aside>
        </div>
    </main>

    <footer>
        <div class="container">
            <p>&copy; 2024 Issam Sayyaf. All rights reserved.</p>
        </div>
    </footer>
</body>
</html> 